// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Bytes,
  BigInt,
  BigDecimal,
} from "@graphprotocol/graph-ts";

export class AminalFactory extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save AminalFactory entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type AminalFactory must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("AminalFactory", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): AminalFactory | null {
    return changetype<AminalFactory | null>(
      store.get_in_block("AminalFactory", id.toHexString()),
    );
  }

  static load(id: Bytes): AminalFactory | null {
    return changetype<AminalFactory | null>(
      store.get("AminalFactory", id.toHexString()),
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get totalAminals(): BigInt {
    let value = this.get("totalAminals");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set totalAminals(value: BigInt) {
    this.set("totalAminals", Value.fromBigInt(value));
  }

  get geneAuction(): Bytes {
    let value = this.get("geneAuction");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set geneAuction(value: Bytes) {
    this.set("geneAuction", Value.fromBytes(value));
  }

  get genes(): Bytes {
    let value = this.get("genes");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set genes(value: Bytes) {
    this.set("genes", Value.fromBytes(value));
  }

  get loveVRGDA(): Bytes {
    let value = this.get("loveVRGDA");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set loveVRGDA(value: Bytes) {
    this.set("loveVRGDA", Value.fromBytes(value));
  }

  get initialAminalSpawned(): boolean {
    let value = this.get("initialAminalSpawned");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set initialAminalSpawned(value: boolean) {
    this.set("initialAminalSpawned", Value.fromBoolean(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }

  get aminals(): AminalLoader {
    return new AminalLoader(
      "AminalFactory",
      this.get("id")!.toBytes().toHexString(),
      "aminals",
    );
  }
}

export class Aminal extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Aminal entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type Aminal must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("Aminal", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): Aminal | null {
    return changetype<Aminal | null>(
      store.get_in_block("Aminal", id.toHexString()),
    );
  }

  static load(id: Bytes): Aminal | null {
    return changetype<Aminal | null>(store.get("Aminal", id.toHexString()));
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get contractAddress(): Bytes {
    let value = this.get("contractAddress");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set contractAddress(value: Bytes) {
    this.set("contractAddress", Value.fromBytes(value));
  }

  get aminalIndex(): BigInt {
    let value = this.get("aminalIndex");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set aminalIndex(value: BigInt) {
    this.set("aminalIndex", Value.fromBigInt(value));
  }

  get factory(): Bytes {
    let value = this.get("factory");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set factory(value: Bytes) {
    this.set("factory", Value.fromBytes(value));
  }

  get momAddress(): Bytes | null {
    let value = this.get("momAddress");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set momAddress(value: Bytes | null) {
    if (!value) {
      this.unset("momAddress");
    } else {
      this.set("momAddress", Value.fromBytes(<Bytes>value));
    }
  }

  get dadAddress(): Bytes | null {
    let value = this.get("dadAddress");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set dadAddress(value: Bytes | null) {
    if (!value) {
      this.unset("dadAddress");
    } else {
      this.set("dadAddress", Value.fromBytes(<Bytes>value));
    }
  }

  get mother(): Bytes | null {
    let value = this.get("mother");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set mother(value: Bytes | null) {
    if (!value) {
      this.unset("mother");
    } else {
      this.set("mother", Value.fromBytes(<Bytes>value));
    }
  }

  get father(): Bytes | null {
    let value = this.get("father");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set father(value: Bytes | null) {
    if (!value) {
      this.unset("father");
    } else {
      this.set("father", Value.fromBytes(<Bytes>value));
    }
  }

  get children(): AminalLoader {
    return new AminalLoader(
      "Aminal",
      this.get("id")!.toBytes().toHexString(),
      "children",
    );
  }

  get backId(): BigInt {
    let value = this.get("backId");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set backId(value: BigInt) {
    this.set("backId", Value.fromBigInt(value));
  }

  get armId(): BigInt {
    let value = this.get("armId");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set armId(value: BigInt) {
    this.set("armId", Value.fromBigInt(value));
  }

  get tailId(): BigInt {
    let value = this.get("tailId");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set tailId(value: BigInt) {
    this.set("tailId", Value.fromBigInt(value));
  }

  get earsId(): BigInt {
    let value = this.get("earsId");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set earsId(value: BigInt) {
    this.set("earsId", Value.fromBigInt(value));
  }

  get bodyId(): BigInt {
    let value = this.get("bodyId");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set bodyId(value: BigInt) {
    this.set("bodyId", Value.fromBigInt(value));
  }

  get faceId(): BigInt {
    let value = this.get("faceId");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set faceId(value: BigInt) {
    this.set("faceId", Value.fromBigInt(value));
  }

  get mouthId(): BigInt {
    let value = this.get("mouthId");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set mouthId(value: BigInt) {
    this.set("mouthId", Value.fromBigInt(value));
  }

  get miscId(): BigInt {
    let value = this.get("miscId");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set miscId(value: BigInt) {
    this.set("miscId", Value.fromBigInt(value));
  }

  get tokenURI(): string | null {
    let value = this.get("tokenURI");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set tokenURI(value: string | null) {
    if (!value) {
      this.unset("tokenURI");
    } else {
      this.set("tokenURI", Value.fromString(<string>value));
    }
  }

  get energy(): BigInt {
    let value = this.get("energy");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set energy(value: BigInt) {
    this.set("energy", Value.fromBigInt(value));
  }

  get totalLove(): BigInt {
    let value = this.get("totalLove");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set totalLove(value: BigInt) {
    this.set("totalLove", Value.fromBigInt(value));
  }

  get breeding(): boolean {
    let value = this.get("breeding");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set breeding(value: boolean) {
    this.set("breeding", Value.fromBoolean(value));
  }

  get breedableWith(): BreedingConsentLoader {
    return new BreedingConsentLoader(
      "Aminal",
      this.get("id")!.toBytes().toHexString(),
      "breedableWith",
    );
  }

  get lovers(): RelationshipLoader {
    return new RelationshipLoader(
      "Aminal",
      this.get("id")!.toBytes().toHexString(),
      "lovers",
    );
  }

  get skillUsed(): SkillUsedLoader {
    return new SkillUsedLoader(
      "Aminal",
      this.get("id")!.toBytes().toHexString(),
      "skillUsed",
    );
  }

  get squeaks(): SqueakLoader {
    return new SqueakLoader(
      "Aminal",
      this.get("id")!.toBytes().toHexString(),
      "squeaks",
    );
  }

  get feeds(): FeedAminalEventLoader {
    return new FeedAminalEventLoader(
      "Aminal",
      this.get("id")!.toBytes().toHexString(),
      "feeds",
    );
  }

  get breedingEventsAsParentOne(): BreedAminalEventLoader {
    return new BreedAminalEventLoader(
      "Aminal",
      this.get("id")!.toBytes().toHexString(),
      "breedingEventsAsParentOne",
    );
  }

  get breedingEventsAsParentTwo(): BreedAminalEventLoader {
    return new BreedAminalEventLoader(
      "Aminal",
      this.get("id")!.toBytes().toHexString(),
      "breedingEventsAsParentTwo",
    );
  }

  get auctions(): GeneAuctionLoader {
    return new GeneAuctionLoader(
      "Aminal",
      this.get("id")!.toBytes().toHexString(),
      "auctions",
    );
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class User extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save User entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type User must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("User", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): User | null {
    return changetype<User | null>(
      store.get_in_block("User", id.toHexString()),
    );
  }

  static load(id: Bytes): User | null {
    return changetype<User | null>(store.get("User", id.toHexString()));
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get address(): Bytes {
    let value = this.get("address");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set address(value: Bytes) {
    this.set("address", Value.fromBytes(value));
  }

  get lovers(): RelationshipLoader {
    return new RelationshipLoader(
      "User",
      this.get("id")!.toBytes().toHexString(),
      "lovers",
    );
  }

  get geneProposals(): GeneProposalLoader {
    return new GeneProposalLoader(
      "User",
      this.get("id")!.toBytes().toHexString(),
      "geneProposals",
    );
  }

  get genesCreated(): GeneNFTLoader {
    return new GeneNFTLoader(
      "User",
      this.get("id")!.toBytes().toHexString(),
      "genesCreated",
    );
  }

  get genesOwned(): GeneNFTLoader {
    return new GeneNFTLoader(
      "User",
      this.get("id")!.toBytes().toHexString(),
      "genesOwned",
    );
  }

  get geneVotes(): GeneVoteLoader {
    return new GeneVoteLoader(
      "User",
      this.get("id")!.toBytes().toHexString(),
      "geneVotes",
    );
  }
}

export class Relationship extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Relationship entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type Relationship must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("Relationship", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): Relationship | null {
    return changetype<Relationship | null>(
      store.get_in_block("Relationship", id.toHexString()),
    );
  }

  static load(id: Bytes): Relationship | null {
    return changetype<Relationship | null>(
      store.get("Relationship", id.toHexString()),
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get user(): Bytes {
    let value = this.get("user");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set user(value: Bytes) {
    this.set("user", Value.fromBytes(value));
  }

  get aminal(): Bytes {
    let value = this.get("aminal");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set aminal(value: Bytes) {
    this.set("aminal", Value.fromBytes(value));
  }

  get love(): BigInt {
    let value = this.get("love");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set love(value: BigInt) {
    this.set("love", Value.fromBigInt(value));
  }
}

export class BreedingConsent extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save BreedingConsent entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type BreedingConsent must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("BreedingConsent", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): BreedingConsent | null {
    return changetype<BreedingConsent | null>(
      store.get_in_block("BreedingConsent", id.toHexString()),
    );
  }

  static load(id: Bytes): BreedingConsent | null {
    return changetype<BreedingConsent | null>(
      store.get("BreedingConsent", id.toHexString()),
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get aminal(): Bytes {
    let value = this.get("aminal");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set aminal(value: Bytes) {
    this.set("aminal", Value.fromBytes(value));
  }

  get partner(): Bytes {
    let value = this.get("partner");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set partner(value: Bytes) {
    this.set("partner", Value.fromBytes(value));
  }

  get consented(): boolean {
    let value = this.get("consented");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set consented(value: boolean) {
    this.set("consented", Value.fromBoolean(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class BreedAminalEvent extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save BreedAminalEvent entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type BreedAminalEvent must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("BreedAminalEvent", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): BreedAminalEvent | null {
    return changetype<BreedAminalEvent | null>(
      store.get_in_block("BreedAminalEvent", id.toHexString()),
    );
  }

  static load(id: Bytes): BreedAminalEvent | null {
    return changetype<BreedAminalEvent | null>(
      store.get("BreedAminalEvent", id.toHexString()),
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get aminalOne(): Bytes {
    let value = this.get("aminalOne");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set aminalOne(value: Bytes) {
    this.set("aminalOne", Value.fromBytes(value));
  }

  get aminalTwo(): Bytes {
    let value = this.get("aminalTwo");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set aminalTwo(value: Bytes) {
    this.set("aminalTwo", Value.fromBytes(value));
  }

  get auctionId(): BigInt {
    let value = this.get("auctionId");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set auctionId(value: BigInt) {
    this.set("auctionId", Value.fromBigInt(value));
  }

  get auction(): Bytes | null {
    let value = this.get("auction");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set auction(value: Bytes | null) {
    if (!value) {
      this.unset("auction");
    } else {
      this.set("auction", Value.fromBytes(<Bytes>value));
    }
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class FeedAminalEvent extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save FeedAminalEvent entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type FeedAminalEvent must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("FeedAminalEvent", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): FeedAminalEvent | null {
    return changetype<FeedAminalEvent | null>(
      store.get_in_block("FeedAminalEvent", id.toHexString()),
    );
  }

  static load(id: Bytes): FeedAminalEvent | null {
    return changetype<FeedAminalEvent | null>(
      store.get("FeedAminalEvent", id.toHexString()),
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get aminal(): Bytes {
    let value = this.get("aminal");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set aminal(value: Bytes) {
    this.set("aminal", Value.fromBytes(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get love(): BigInt {
    let value = this.get("love");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set love(value: BigInt) {
    this.set("love", Value.fromBigInt(value));
  }

  get totalLove(): BigInt {
    let value = this.get("totalLove");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set totalLove(value: BigInt) {
    this.set("totalLove", Value.fromBigInt(value));
  }

  get energy(): BigInt {
    let value = this.get("energy");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set energy(value: BigInt) {
    this.set("energy", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class SkillUsed extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save SkillUsed entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type SkillUsed must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("SkillUsed", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): SkillUsed | null {
    return changetype<SkillUsed | null>(
      store.get_in_block("SkillUsed", id.toHexString()),
    );
  }

  static load(id: Bytes): SkillUsed | null {
    return changetype<SkillUsed | null>(
      store.get("SkillUsed", id.toHexString()),
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get aminal(): Bytes {
    let value = this.get("aminal");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set aminal(value: Bytes) {
    this.set("aminal", Value.fromBytes(value));
  }

  get caller(): Bytes {
    let value = this.get("caller");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set caller(value: Bytes) {
    this.set("caller", Value.fromBytes(value));
  }

  get skillAddress(): Bytes {
    let value = this.get("skillAddress");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set skillAddress(value: Bytes) {
    this.set("skillAddress", Value.fromBytes(value));
  }

  get selector(): Bytes {
    let value = this.get("selector");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set selector(value: Bytes) {
    this.set("selector", Value.fromBytes(value));
  }

  get newEnergy(): BigInt {
    let value = this.get("newEnergy");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set newEnergy(value: BigInt) {
    this.set("newEnergy", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class GlobalSkill extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save GlobalSkill entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type GlobalSkill must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("GlobalSkill", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): GlobalSkill | null {
    return changetype<GlobalSkill | null>(
      store.get_in_block("GlobalSkill", id.toHexString()),
    );
  }

  static load(id: Bytes): GlobalSkill | null {
    return changetype<GlobalSkill | null>(
      store.get("GlobalSkill", id.toHexString()),
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get skillAddress(): Bytes {
    let value = this.get("skillAddress");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set skillAddress(value: Bytes) {
    this.set("skillAddress", Value.fromBytes(value));
  }

  get name(): string | null {
    let value = this.get("name");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set name(value: string | null) {
    if (!value) {
      this.unset("name");
    } else {
      this.set("name", Value.fromString(<string>value));
    }
  }

  get callCount(): BigInt {
    let value = this.get("callCount");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set callCount(value: BigInt) {
    this.set("callCount", Value.fromBigInt(value));
  }

  get totalSqueakCost(): BigInt {
    let value = this.get("totalSqueakCost");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set totalSqueakCost(value: BigInt) {
    this.set("totalSqueakCost", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class Squeak extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Squeak entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type Squeak must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("Squeak", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): Squeak | null {
    return changetype<Squeak | null>(
      store.get_in_block("Squeak", id.toHexString()),
    );
  }

  static load(id: Bytes): Squeak | null {
    return changetype<Squeak | null>(store.get("Squeak", id.toHexString()));
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get aminal(): Bytes {
    let value = this.get("aminal");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set aminal(value: Bytes) {
    this.set("aminal", Value.fromBytes(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get love(): BigInt {
    let value = this.get("love");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set love(value: BigInt) {
    this.set("love", Value.fromBigInt(value));
  }

  get totalLove(): BigInt {
    let value = this.get("totalLove");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set totalLove(value: BigInt) {
    this.set("totalLove", Value.fromBigInt(value));
  }

  get energy(): BigInt {
    let value = this.get("energy");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set energy(value: BigInt) {
    this.set("energy", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class GeneAuction extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save GeneAuction entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type GeneAuction must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("GeneAuction", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): GeneAuction | null {
    return changetype<GeneAuction | null>(
      store.get_in_block("GeneAuction", id.toHexString()),
    );
  }

  static load(id: Bytes): GeneAuction | null {
    return changetype<GeneAuction | null>(
      store.get("GeneAuction", id.toHexString()),
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get auctionId(): BigInt {
    let value = this.get("auctionId");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set auctionId(value: BigInt) {
    this.set("auctionId", Value.fromBigInt(value));
  }

  get aminalOne(): Bytes {
    let value = this.get("aminalOne");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set aminalOne(value: Bytes) {
    this.set("aminalOne", Value.fromBytes(value));
  }

  get aminalTwo(): Bytes {
    let value = this.get("aminalTwo");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set aminalTwo(value: Bytes) {
    this.set("aminalTwo", Value.fromBytes(value));
  }

  get totalLove(): BigInt {
    let value = this.get("totalLove");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set totalLove(value: BigInt) {
    this.set("totalLove", Value.fromBigInt(value));
  }

  get finished(): boolean {
    let value = this.get("finished");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set finished(value: boolean) {
    this.set("finished", Value.fromBoolean(value));
  }

  get childAminal(): Bytes | null {
    let value = this.get("childAminal");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set childAminal(value: Bytes | null) {
    if (!value) {
      this.unset("childAminal");
    } else {
      this.set("childAminal", Value.fromBytes(<Bytes>value));
    }
  }

  get winningGeneIds(): Array<BigInt> | null {
    let value = this.get("winningGeneIds");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigIntArray();
    }
  }

  set winningGeneIds(value: Array<BigInt> | null) {
    if (!value) {
      this.unset("winningGeneIds");
    } else {
      this.set("winningGeneIds", Value.fromBigIntArray(<Array<BigInt>>value));
    }
  }

  get proposals(): GeneProposalLoader {
    return new GeneProposalLoader(
      "GeneAuction",
      this.get("id")!.toBytes().toHexString(),
      "proposals",
    );
  }

  get votes(): GeneVoteLoader {
    return new GeneVoteLoader(
      "GeneAuction",
      this.get("id")!.toBytes().toHexString(),
      "votes",
    );
  }

  get payouts(): GeneCreatorPayoutLoader {
    return new GeneCreatorPayoutLoader(
      "GeneAuction",
      this.get("id")!.toBytes().toHexString(),
      "payouts",
    );
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }

  get endBlockNumber(): BigInt | null {
    let value = this.get("endBlockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set endBlockNumber(value: BigInt | null) {
    if (!value) {
      this.unset("endBlockNumber");
    } else {
      this.set("endBlockNumber", Value.fromBigInt(<BigInt>value));
    }
  }

  get endBlockTimestamp(): BigInt | null {
    let value = this.get("endBlockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set endBlockTimestamp(value: BigInt | null) {
    if (!value) {
      this.unset("endBlockTimestamp");
    } else {
      this.set("endBlockTimestamp", Value.fromBigInt(<BigInt>value));
    }
  }

  get endTransactionHash(): Bytes | null {
    let value = this.get("endTransactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set endTransactionHash(value: Bytes | null) {
    if (!value) {
      this.unset("endTransactionHash");
    } else {
      this.set("endTransactionHash", Value.fromBytes(<Bytes>value));
    }
  }
}

export class GeneNFT extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save GeneNFT entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type GeneNFT must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("GeneNFT", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): GeneNFT | null {
    return changetype<GeneNFT | null>(
      store.get_in_block("GeneNFT", id.toHexString()),
    );
  }

  static load(id: Bytes): GeneNFT | null {
    return changetype<GeneNFT | null>(store.get("GeneNFT", id.toHexString()));
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get tokenId(): BigInt {
    let value = this.get("tokenId");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set tokenId(value: BigInt) {
    this.set("tokenId", Value.fromBigInt(value));
  }

  get traitType(): i32 {
    let value = this.get("traitType");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set traitType(value: i32) {
    this.set("traitType", Value.fromI32(value));
  }

  get owner(): Bytes {
    let value = this.get("owner");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set owner(value: Bytes) {
    this.set("owner", Value.fromBytes(value));
  }

  get creator(): Bytes {
    let value = this.get("creator");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set creator(value: Bytes) {
    this.set("creator", Value.fromBytes(value));
  }

  get svg(): string | null {
    let value = this.get("svg");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set svg(value: string | null) {
    if (!value) {
      this.unset("svg");
    } else {
      this.set("svg", Value.fromString(<string>value));
    }
  }

  get name(): string | null {
    let value = this.get("name");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set name(value: string | null) {
    if (!value) {
      this.unset("name");
    } else {
      this.set("name", Value.fromString(<string>value));
    }
  }

  get description(): string | null {
    let value = this.get("description");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set description(value: string | null) {
    if (!value) {
      this.unset("description");
    } else {
      this.set("description", Value.fromString(<string>value));
    }
  }

  get proposalsUsingGene(): GeneProposalLoader {
    return new GeneProposalLoader(
      "GeneNFT",
      this.get("id")!.toBytes().toHexString(),
      "proposalsUsingGene",
    );
  }

  get totalEarnings(): BigInt {
    let value = this.get("totalEarnings");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set totalEarnings(value: BigInt) {
    this.set("totalEarnings", Value.fromBigInt(value));
  }

  get payouts(): GeneCreatorPayoutLoader {
    return new GeneCreatorPayoutLoader(
      "GeneNFT",
      this.get("id")!.toBytes().toHexString(),
      "payouts",
    );
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class GeneProposal extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save GeneProposal entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type GeneProposal must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("GeneProposal", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): GeneProposal | null {
    return changetype<GeneProposal | null>(
      store.get_in_block("GeneProposal", id.toHexString()),
    );
  }

  static load(id: Bytes): GeneProposal | null {
    return changetype<GeneProposal | null>(
      store.get("GeneProposal", id.toHexString()),
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get auction(): Bytes {
    let value = this.get("auction");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set auction(value: Bytes) {
    this.set("auction", Value.fromBytes(value));
  }

  get geneNFT(): Bytes {
    let value = this.get("geneNFT");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set geneNFT(value: Bytes) {
    this.set("geneNFT", Value.fromBytes(value));
  }

  get traitType(): i32 {
    let value = this.get("traitType");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set traitType(value: i32) {
    this.set("traitType", Value.fromI32(value));
  }

  get proposer(): Bytes {
    let value = this.get("proposer");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set proposer(value: Bytes) {
    this.set("proposer", Value.fromBytes(value));
  }

  get loveVotes(): BigInt {
    let value = this.get("loveVotes");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set loveVotes(value: BigInt) {
    this.set("loveVotes", Value.fromBigInt(value));
  }

  get removeVotes(): BigInt {
    let value = this.get("removeVotes");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set removeVotes(value: BigInt) {
    this.set("removeVotes", Value.fromBigInt(value));
  }

  get removed(): boolean {
    let value = this.get("removed");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set removed(value: boolean) {
    this.set("removed", Value.fromBoolean(value));
  }

  get votes(): GeneVoteLoader {
    return new GeneVoteLoader(
      "GeneProposal",
      this.get("id")!.toBytes().toHexString(),
      "votes",
    );
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class GeneVote extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save GeneVote entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type GeneVote must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("GeneVote", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): GeneVote | null {
    return changetype<GeneVote | null>(
      store.get_in_block("GeneVote", id.toHexString()),
    );
  }

  static load(id: Bytes): GeneVote | null {
    return changetype<GeneVote | null>(store.get("GeneVote", id.toHexString()));
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get auction(): Bytes {
    let value = this.get("auction");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set auction(value: Bytes) {
    this.set("auction", Value.fromBytes(value));
  }

  get proposal(): Bytes {
    let value = this.get("proposal");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set proposal(value: Bytes) {
    this.set("proposal", Value.fromBytes(value));
  }

  get voter(): Bytes {
    let value = this.get("voter");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set voter(value: Bytes) {
    this.set("voter", Value.fromBytes(value));
  }

  get isRemoveVote(): boolean {
    let value = this.get("isRemoveVote");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set isRemoveVote(value: boolean) {
    this.set("isRemoveVote", Value.fromBoolean(value));
  }

  get loveAmount(): BigInt {
    let value = this.get("loveAmount");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set loveAmount(value: BigInt) {
    this.set("loveAmount", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class GeneCreatorPayout extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save GeneCreatorPayout entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type GeneCreatorPayout must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("GeneCreatorPayout", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): GeneCreatorPayout | null {
    return changetype<GeneCreatorPayout | null>(
      store.get_in_block("GeneCreatorPayout", id.toHexString()),
    );
  }

  static load(id: Bytes): GeneCreatorPayout | null {
    return changetype<GeneCreatorPayout | null>(
      store.get("GeneCreatorPayout", id.toHexString()),
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get auction(): Bytes {
    let value = this.get("auction");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set auction(value: Bytes) {
    this.set("auction", Value.fromBytes(value));
  }

  get geneNFT(): Bytes {
    let value = this.get("geneNFT");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set geneNFT(value: Bytes) {
    this.set("geneNFT", Value.fromBytes(value));
  }

  get creator(): Bytes {
    let value = this.get("creator");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set creator(value: Bytes) {
    this.set("creator", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get auctionId(): BigInt {
    let value = this.get("auctionId");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set auctionId(value: BigInt) {
    this.set("auctionId", Value.fromBigInt(value));
  }

  get geneId(): BigInt {
    let value = this.get("geneId");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set geneId(value: BigInt) {
    this.set("geneId", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class AminalLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): Aminal[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<Aminal[]>(value);
  }
}

export class BreedingConsentLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): BreedingConsent[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<BreedingConsent[]>(value);
  }
}

export class RelationshipLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): Relationship[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<Relationship[]>(value);
  }
}

export class SkillUsedLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): SkillUsed[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<SkillUsed[]>(value);
  }
}

export class SqueakLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): Squeak[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<Squeak[]>(value);
  }
}

export class FeedAminalEventLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): FeedAminalEvent[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<FeedAminalEvent[]>(value);
  }
}

export class BreedAminalEventLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): BreedAminalEvent[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<BreedAminalEvent[]>(value);
  }
}

export class GeneAuctionLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): GeneAuction[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<GeneAuction[]>(value);
  }
}

export class GeneProposalLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): GeneProposal[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<GeneProposal[]>(value);
  }
}

export class GeneNFTLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): GeneNFT[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<GeneNFT[]>(value);
  }
}

export class GeneVoteLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): GeneVote[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<GeneVote[]>(value);
  }
}

export class GeneCreatorPayoutLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): GeneCreatorPayout[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<GeneCreatorPayout[]>(value);
  }
}
